<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Item Database</title>
<style>
:root{
  --bg0:#070A12;
  --bg1:#0B1020;
  --border:rgba(255,255,255,.08);
  --border2:rgba(255,255,255,.12);
  --text:#E7EAF2;
  --muted:#A8B1C2;
  --muted2:#7F8AA1;
  --accent:#62B0FF;
  --accent2:#8B5CFF;
  --shadow: 0 12px 40px rgba(0,0,0,.45);
  --shadow2: 0 10px 30px rgba(0,0,0,.35);
  --radius: 18px;
}

*{ box-sizing:border-box; }
html,body{ height:100%; }

body{
  margin:0;
  font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
  color: var(--text);
  background:
    radial-gradient(1200px 800px at 20% 10%, rgba(98,176,255,.16), transparent 60%),
    radial-gradient(1000px 700px at 85% 20%, rgba(139,92,255,.12), transparent 55%),
    linear-gradient(180deg, var(--bg0), var(--bg1));
}

header{
  position: sticky;
  top: 0;
  z-index: 10;
  padding: 16px 22px;
  border-bottom: 1px solid var(--border);
  background: linear-gradient(180deg, rgba(16,26,49,.92), rgba(11,16,32,.82));
  backdrop-filter: blur(10px);
}

.header-inner{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap: 14px;
}

.brand{
  display:flex;
  align-items:center;
  gap: 10px;
  font-weight: 700;
  letter-spacing: .2px;
  font-size: 18px;
}

.badge{
  font-size: 12px;
  padding: 4px 10px;
  border-radius: 999px;
  color: rgba(231,234,242,.9);
  border: 1px solid var(--border);
  background: rgba(255,255,255,.04);
}

main{
  display:grid;
  grid-template-columns: 360px 1fr;
  min-height: calc(100vh - 60px);
}

aside{
  border-right: 1px solid var(--border);
  background: linear-gradient(180deg, rgba(16,26,49,.55), rgba(11,16,32,.4));
  padding: 14px;
  overflow: auto;
}

.panel{
  border: 1px solid var(--border);
  background: linear-gradient(180deg, rgba(14,20,38,.75), rgba(11,16,32,.55));
  border-radius: var(--radius);
  box-shadow: var(--shadow2);
  overflow: hidden;
}

.sidebar-top{
  padding: 14px;
  border-bottom: 1px solid var(--border);
}

.search{
  display:flex;
  align-items:center;
  gap: 10px;
  padding: 10px 12px;
  border-radius: 14px;
  border: 1px solid var(--border);
  background: rgba(255,255,255,.03);
}

.search input{
  width:100%;
  border:none;
  outline:none;
  background: transparent;
  color: var(--text);
  font-size: 14px;
}

.search input::placeholder{ color: var(--muted2); }

.hint{
  margin-top: 10px;
  color: var(--muted2);
  font-size: 12px;
  line-height: 1.35;
}

.sidebar-scroll{
  padding: 10px;
}

.group{ margin: 6px 0; }

.group-title{
  width: 100%;
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap: 10px;
  padding: 10px 12px;
  border-radius: 14px;
  cursor: pointer;
  user-select:none;
  color: rgba(231,234,242,.95);
  background: rgba(255,255,255,.02);
  border: 1px solid rgba(255,255,255,.06);
  transition: background .15s ease, border-color .15s ease;
}
.group-title:hover{
  background: rgba(98,176,255,.08);
  border-color: rgba(98,176,255,.18);
}

.chev{
  width: 28px;
  height: 28px;
  display:grid;
  place-items:center;
  border-radius: 10px;
  border: 1px solid rgba(255,255,255,.06);
  background: rgba(255,255,255,.03);
}
.group.open .chev{
  border-color: rgba(98,176,255,.25);
  background: rgba(98,176,255,.10);
}

.group-content{
  display:none;
  margin: 10px 0 14px 10px;
  padding-left: 10px;
  border-left: 1px solid rgba(255,255,255,.08);
}
.group.open .group-content{ display:block; }

.subgroup{ margin: 8px 0; }

.subgroup-title{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap: 10px;
  padding: 8px 10px;
  border-radius: 12px;
  cursor: pointer;
  user-select:none;
  color: rgba(231,234,242,.9);
  background: rgba(255,255,255,.02);
  border: 1px solid rgba(255,255,255,.06);
}
.subgroup-title:hover{
  background: rgba(255,255,255,.05);
  border-color: rgba(255,255,255,.10);
}

.subgroup .item-list{
  display:none;
  padding: 8px 0 0 10px;
}
.subgroup.open .item-list{ display:block; }

.item{
  padding: 7px 10px;
  border-radius: 12px;
  cursor:pointer;
  color: var(--muted);
  border: 1px solid transparent;
  transition: background .15s ease, color .15s ease, border-color .15s ease;
}
.item:hover{
  background: rgba(255,255,255,.05);
  color: rgba(231,234,242,.95);
  border-color: rgba(255,255,255,.06);
}
.item.active{
  background: linear-gradient(180deg, rgba(98,176,255,.16), rgba(98,176,255,.08));
  color: #fff;
  border-color: rgba(98,176,255,.28);
}

section{
  padding: 24px;
  overflow: auto;
}

.card{
  max-width: 1180px;
  border: 1px solid var(--border);
  border-radius: 22px;
  box-shadow: var(--shadow);
  background: linear-gradient(180deg, rgba(16,26,49,.75), rgba(11,16,32,.58));
  overflow: hidden;
}

.card-header{
  display:flex;
  gap: 18px;
  padding: 18px 18px 14px 18px;
  align-items:center;
  border-bottom: 1px solid var(--border);
  background:
    radial-gradient(900px 220px at 20% 0%, rgba(98,176,255,.18), transparent 60%),
    radial-gradient(700px 240px at 90% 30%, rgba(139,92,255,.12), transparent 55%),
    linear-gradient(180deg, rgba(14,20,38,.55), rgba(11,16,32,.35));
}

.thumb{
  width: 92px;
  height: 92px;
  border-radius: 20px;
  overflow:hidden;
  border: 1px solid rgba(255,255,255,.10);
  background: rgba(255,255,255,.04);
  display:grid;
  place-items:center;
  flex: 0 0 auto;
  position: relative;
}
.thumb img{
  width:100%;
  height:100%;
  object-fit: cover;
  opacity: 0;
  transition: opacity .25s ease;
}
.thumb .loading{
  position:absolute;
  inset:0;
  display:grid;
  place-items:center;
  color: rgba(231,234,242,.72);
  font-size: 12px;
}
.thumb .noimg{
  color: rgba(231,234,242,.65);
  font-size: 12px;
}

.title-wrap{ min-width: 0; }

.h1{
  margin: 0;
  font-size: 22px;
  font-weight: 750;
  letter-spacing: .2px;
}

.subtitle{
  margin-top: 6px;
  color: var(--muted);
  font-size: 13px;
}

.pills{
  margin-top: 10px;
  display:flex;
  flex-wrap: wrap;
  gap: 8px;
}

.pill{
  font-size: 12px;
  padding: 5px 10px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,.10);
  background: rgba(255,255,255,.04);
  color: rgba(231,234,242,.92);
}

.card-body{ padding: 18px; }

/* New: sectioned tables instead of many separate cards */
.sections{
  display:grid;
  grid-template-columns: 1fr;
  gap: 14px;
}

.section-box{
  border: 1px solid rgba(255,255,255,.08);
  border-radius: 18px;
  background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.015));
  overflow: hidden;
}

.section-head{
  display:flex;
  align-items:center;
  justify-content:space-between;
  padding: 12px 14px;
  border-bottom: 1px solid rgba(255,255,255,.08);
  background: rgba(0,0,0,.12);
}

.section-title{
  font-size: 12px;
  letter-spacing: .18em;
  text-transform: uppercase;
  color: rgba(168,177,194,.95);
  font-weight: 650;
}

.section-body{
  padding: 10px 12px 12px 12px;
}

.table{
  width:100%;
  border-collapse: separate;
  border-spacing: 0;
  overflow:hidden;
  border: 1px solid rgba(255,255,255,.08);
  border-radius: 14px;
  background: rgba(0,0,0,.14);
}

.table th, .table td{
  padding: 10px 10px;
  font-size: 13px;
  vertical-align: top;
  border-bottom: 1px solid rgba(255,255,255,.06);
}

.table th{
  text-align:left;
  color: rgba(168,177,194,.95);
  font-size: 12px;
  letter-spacing: .12em;
  text-transform: uppercase;
  background: rgba(255,255,255,.03);
}

.table tr:last-child td{
  border-bottom: none;
}

.table td.key{
  color: rgba(168,177,194,.95);
  width: 30%;
  font-size: 12px;
  letter-spacing: .10em;
  text-transform: uppercase;
}

.table td.val{
  color: rgba(231,234,242,.96);
  font-variant-numeric: tabular-nums;
}

.mono{
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
  font-size: 12px;
}

.codebox{
  margin-top: 8px;
  padding: 10px 10px;
  border-radius: 12px;
  border: 1px solid rgba(255,255,255,.08);
  background: rgba(0,0,0,.16);
  overflow:auto;
  color: rgba(231,234,242,.92);
  white-space: pre-wrap;
  word-break: break-word;
}

.placeholder{
  color: var(--muted);
  border: 1px dashed rgba(255,255,255,.16);
  border-radius: 18px;
  padding: 18px;
  max-width: 1100px;
  background: rgba(255,255,255,.02);
}

@media (max-width: 980px){
  main{ grid-template-columns: 1fr; }
  aside{ border-right: none; border-bottom: 1px solid var(--border); }
  .table td.key{ width: 38%; }
}
</style>
</head>
<body>
<header>
  <div class="header-inner">
    <div class="brand">
      Item Database
      <span class="badge" id="counts">Loading…</span>
    </div>
    <div class="badge">GitHub Pages-ready</div>
  </div>
</header>

<main>
  <aside>
    <div class="panel">
      <div class="sidebar-top">
        <div class="search">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" aria-hidden="true">
            <path d="M10.5 18a7.5 7.5 0 1 1 0-15 7.5 7.5 0 0 1 0 15Z" stroke="currentColor" stroke-width="2" opacity=".9"/>
            <path d="M16.5 16.5 21 21" stroke="currentColor" stroke-width="2" stroke-linecap="round" opacity=".9"/>
          </svg>
          <input id="search" type="text" placeholder="Search items (name, category, subgroup)..." />
        </div>
        <div class="hint">Tip: search auto-expands and jumps to the first match.</div>
      </div>
      <div class="sidebar-scroll" id="sidebar"></div>
    </div>
  </aside>

  <section id="content">
    <div class="placeholder">Select an item to view its details.</div>
  </section>
</main>

<script>
function titleCase(s){
  return String(s).replace(/_/g,' ').replace(/\b\w/g, m => m.toUpperCase());
}
function normalizeCategory(path){
  const parts = String(path).split('/');
  const group = (parts[0] || 'misc').toLowerCase();
  const sub = (parts[1] || '').replace(/\.lua$/i,'');
  return { group, sub: sub || 'misc' };
}
function isPlainObject(v){
  return v && typeof v === 'object' && !Array.isArray(v);
}
function formatScalar(v){
  if (v === null) return '∞';
  if (typeof v === 'boolean') return v ? 'true' : 'false';
  return String(v);
}

function extractLooseBracketMap(obj){
  // Some recipe tables were flattened during export into keys like ["AURITE BAR"] at the item root.
  // This detects those keys and returns a normalized map + the original keys for hiding them from "Other".
  const map = {};
  const keys = [];
  const re = /^\[\s*["'](.+?)["']\s*\]$/;
  for (const k of Object.keys(obj)){
    const m = k.match(re);
    if (m){
      map[m[1]] = obj[k];
      keys.push(k);
    }
  }
  return { map, keys };
}

function coerceDamages(val){
  // Return a plain object of damage targets -> values, or null if not usable.
  if (isPlainObject(val)) return val;

  if (typeof val === 'string'){
    const t = val.trim();
    if (!t) return null;

    // Try JSON parse (sometimes damages were stringified)
    try{
      const parsed = JSON.parse(t);
      if (isPlainObject(parsed)) return parsed;
    }catch(e){}

    // Try a lenient parse for single quotes / trailing commas (best-effort)
    try{
      const fixed = t
        .replace(/\r?\n/g,' ')
        .replace(/'/g,'"')
        .replace(/,\s*}/g,'}')
        .replace(/,\s*]/g,']');
      const parsed2 = JSON.parse(fixed);
      if (isPlainObject(parsed2)) return parsed2;
    }catch(e){}

    return null;
  }

  return null;
}
function extractAssetId(imageField){
  if (imageField === null || imageField === undefined) return null;

  if (typeof imageField === 'number' && Number.isFinite(imageField)) {
    return String(Math.trunc(imageField));
  }
  const s = String(imageField);

  const m1 = s.match(/rbxassetid:\/\/(\d+)/i);
  if (m1) return m1[1];

  const m2 = s.match(/[?&]assetId=(\d+)/i);
  if (m2) return m2[1];

  const m3 = s.match(/[?&]aid=(\d+)/i);
  if (m3) return m3[1];

  const m4 = s.match(/\b(\d{6,})\b/);
  if (m4) return m4[1];

  return null;
}

function extractImageUrl(imageField){
  // Accept direct CDN/thumbnail URLs to avoid extra requests.
  if (imageField === null || imageField === undefined) return null;

  // If the field is an object like { imageUrl: "https://..." }
  if (typeof imageField === 'object' && !Array.isArray(imageField)){
    const u = imageField.imageUrl || imageField.url || imageField.thumbnailUrl;
    if (typeof u === 'string' && /^https?:\/\//i.test(u.trim())) return u.trim();
  }

  if (typeof imageField !== 'string') return null;

  const t = imageField.trim();
  if (!t) return null;

  // Protocol-relative URLs
  if (/^\/\//.test(t)) return 'https:' + t;

  if (/^https?:\/\//i.test(t)) return t;

  return null;
}

// Roblox thumbnails API (assets)
function thumbApiUrl(assetId, size){
  const params = new URLSearchParams({
    assetIds: String(assetId),
    returnPolicy: "PlaceHolder",
    size: size,
    format: "Png",
    isCircular: "false"
  });
  return `https://thumbnails.roblox.com/v1/assets?${params.toString()}`;
}

const thumbCache = new Map(); // assetId -> Promise<string|null>

async function getThumbnailUrl(assetId, preferredSize){
  if (!assetId) return null;
  if (thumbCache.has(assetId)) return thumbCache.get(assetId);

  const p = (async () => {
    const sizesToTry = [preferredSize, "420x420", "150x150", "110x110", "48x48", "30x30"]
      .filter((v, i, a) => v && a.indexOf(v) === i);

    for (const size of sizesToTry){
      try{
        const res = await fetch(thumbApiUrl(assetId, size), { method: "GET" });
        if (!res.ok) continue;
        const js = await res.json();
        const entry = js && js.data && js.data[0];
        if (entry && entry.imageUrl){
          return entry.imageUrl;
        }
      } catch (e) {}
    }
    return null;
  })();

  thumbCache.set(assetId, p);
  return p;
}

/* ---------- Section rendering ---------- */

function makeSection(title){
  const box = document.createElement('div');
  box.className = 'section-box';

  const head = document.createElement('div');
  head.className = 'section-head';

  const t = document.createElement('div');
  t.className = 'section-title';
  t.textContent = title;

  head.appendChild(t);

  const body = document.createElement('div');
  body.className = 'section-body';

  box.appendChild(head);
  box.appendChild(body);

  return { box, body };
}

function tableFromPairs(pairs, headers){
  const table = document.createElement('table');
  table.className = 'table';

  if (headers){
    const thead = document.createElement('thead');
    const tr = document.createElement('tr');
    for (const h of headers){
      const th = document.createElement('th');
      th.textContent = h;
      tr.appendChild(th);
    }
    thead.appendChild(tr);
    table.appendChild(thead);
  }

  const tbody = document.createElement('tbody');
  for (const [k, v] of pairs){
    const tr = document.createElement('tr');

    const tdK = document.createElement('td');
    tdK.className = 'key';
    tdK.textContent = k;

    const tdV = document.createElement('td');
    tdV.className = 'val';
    tdV.appendChild(renderPrettyValue(v));

    tr.appendChild(tdK);
    tr.appendChild(tdV);
    tbody.appendChild(tr);
  }
  table.appendChild(tbody);
  return table;
}

function renderPrettyValue(v){
  // scalar
  if (v === null || typeof v !== 'object'){
    const span = document.createElement('span');
    span.textContent = formatScalar(v);
    return span;
  }

  // array
  if (Array.isArray(v)){
    const div = document.createElement('div');
    div.className = 'codebox mono';
    div.textContent = JSON.stringify(v, null, 2);
    return div;
  }

  // object
  const keys = Object.keys(v);
  const shallowScalarOnly = keys.length <= 10 && keys.every(k => (v[k] === null || typeof v[k] !== 'object'));
  if (shallowScalarOnly){
    // render mini-table inside value
    const innerPairs = keys.sort((a,b)=>a.localeCompare(b)).map(k => [titleCase(k), v[k]]);
    const inner = document.createElement('table');
    inner.className = 'table';
    inner.style.borderRadius = '12px';
    inner.style.margin = '0';
    inner.style.width = '100%';
    const tbody = document.createElement('tbody');
    for (const [k, vv] of innerPairs){
      const tr = document.createElement('tr');
      const td1 = document.createElement('td');
      td1.className = 'key';
      td1.textContent = k;
      const td2 = document.createElement('td');
      td2.className = 'val';
      td2.textContent = formatScalar(vv);
      tr.appendChild(td1); tr.appendChild(td2);
      tbody.appendChild(tr);
    }
    inner.appendChild(tbody);
    return inner;
  }

  // fallback pretty JSON (with infinity symbols)
  const div = document.createElement('div');
  div.className = 'codebox mono';
  const replacer = (k,val)=> (val === null ? '∞' : val);
  div.textContent = JSON.stringify(v, replacer, 2);
  return div;
}

/* ---------- App ---------- */

async function load(){
  const res = await fetch('./items.json');
  const data = await res.json();

  const groups = {};
  let totalGroups = 0, totalItems = 0;

  for (const [path, items] of Object.entries(data)){
    const { group, sub } = normalizeCategory(path);
    groups[group] ??= {};
    groups[group][sub] ??= {};
    Object.assign(groups[group][sub], items);
  }

  totalGroups = Object.keys(groups).length;
  for (const g of Object.values(groups)){
    for (const sub of Object.values(g)){
      totalItems += Object.keys(sub).length;
    }
  }
  document.getElementById('counts').textContent = `${totalGroups} categories • ${totalItems} items`;

  const sidebar = document.getElementById('sidebar');
  const content = document.getElementById('content');
  const search = document.getElementById('search');

  const groupMeta = new Map(); // groupName -> { groupEl, subMap }
  const itemMeta = []; // { itemEl, subgroupEl, groupEl, groupName, subName, itemNameLower, itemData }

  function renderCard(itemName, itemData, meta){
    content.innerHTML = '';

    const card = document.createElement('div');
    card.className = 'card';

    // Header
    const header = document.createElement('div');
    header.className = 'card-header';

    const thumb = document.createElement('div');
    thumb.className = 'thumb';

    const loading = document.createElement('div');
    loading.className = 'loading';
    loading.textContent = 'Loading…';
    thumb.appendChild(loading);

    const img = document.createElement('img');
    img.alt = itemName;

    const directUrl = extractImageUrl(itemData.image);
    const assetId = directUrl ? null : extractAssetId(itemData.image);

    (async () => {
      // If items.json already contains a ready-to-use thumbnail URL, use it directly (no API call).
      if (directUrl){
        img.onload = () => {
          img.style.opacity = '1';
          loading.remove();
        };
        img.onerror = () => {
          loading.remove();
          const no = document.createElement('div');
          no.className = 'noimg';
          no.textContent = 'No image';
          thumb.appendChild(no);
        };
        img.src = directUrl;
        thumb.appendChild(img);
        return;
      }

      // Otherwise fall back to Roblox thumbnails API via assetId.
      if (!assetId){
        loading.remove();
        const no = document.createElement('div');
        no.className = 'noimg';
        no.textContent = 'No image';
        thumb.appendChild(no);
        return;
      }

      const url = await getThumbnailUrl(assetId, "420x420");
      if (!url){
        loading.remove();
        const no = document.createElement('div');
        no.className = 'noimg';
        no.textContent = 'No image';
        thumb.appendChild(no);
        return;
      }

      img.onload = () => {
        img.style.opacity = '1';
        loading.remove();
      };
      img.onerror = () => {
        loading.remove();
        const no = document.createElement('div');
        no.className = 'noimg';
        no.textContent = 'No image';
        thumb.appendChild(no);
      };
      img.src = url;
      thumb.appendChild(img);
    })();
    const tw = document.createElement('div');
    tw.className = 'title-wrap';

    const h = document.createElement('h2');
    h.className = 'h1';
    h.textContent = itemName;

    const sub = document.createElement('div');
    sub.className = 'subtitle';
    const pieces = [];
    if (meta?.group) pieces.push(titleCase(meta.group));
    if (meta?.sub && meta.sub !== 'misc') pieces.push(titleCase(meta.sub));
    sub.textContent = pieces.join(' • ');

    const pills = document.createElement('div');
    pills.className = 'pills';

    const rarity = itemData.Rarity || itemData.rarity;
    const type = itemData.itemType || itemData.type;

    function addPill(text){
      const p = document.createElement('span');
      p.className = 'pill';
      p.textContent = text;
      pills.appendChild(p);
    }

    if (type) addPill(String(type));
    if (rarity) addPill(String(rarity));
    if (itemData.level !== undefined) addPill(`Level ${itemData.level}`);
    if (itemData.coinValue !== undefined) addPill(`Value ${itemData.coinValue}`);

    tw.appendChild(h);
    tw.appendChild(sub);
    if (pills.childElementCount) tw.appendChild(pills);

    header.appendChild(thumb);
    header.appendChild(tw);

    // Body (sectioned tables)
    const body = document.createElement('div');
    body.className = 'card-body';

    const sections = document.createElement('div');
    sections.className = 'sections';

    // Define section keys
    const shown = new Set(['image']);
    const has = (k) => Object.prototype.hasOwnProperty.call(itemData, k);

    const looksCraftable = has('recipe') || has('craftLevel') || has('craftQuantity') || has('mojoRecipe') || has('mojoCost') || has('mojoCostPer') || has('mojoCostPerCraft') || has('mojoCostPerCrafting') || has('mojoCostPerLevel');
    const loose = looksCraftable ? extractLooseBracketMap(itemData) : { map: {}, keys: [] };

    const infoKeys = ['itemType','Rarity','toolType','useType','level','coinValue','description','pickupSound','armorSet','BottomText','color','shopOrder'];
    const statsKeys = ['damages','speed','FlySpeed','protection','locus','maxLoad','load','DisableDoubleResources'];
    const craftKeys = ['craftLevel','craftQuantity','mojoRecipe','mojoCost','mojoCostPer','mojoCostPerCraft','mojoCostPerCrafting','mojoCostPerLevel'];
    const flagsKeys = ['admin','noDrop','rebirthPersist','unobtainable','cosmetic'];

    // Item Info
    const infoPairs = [];
    for (const k of infoKeys){
      if (has(k)){
        infoPairs.push([k, itemData[k]]);
        shown.add(k);
      }
    }
    if (infoPairs.length){
      const sec = makeSection('Item Info');
      sec.body.appendChild(tableFromPairs(infoPairs, ['Field','Value']));
      sections.appendChild(sec.box);
    }
    // Damages (special table)
    const dmgObj = has('damages') ? coerceDamages(itemData.damages) : null;
    if (dmgObj){
      shown.add('damages');
      const dmg = dmgObj;
const sec = makeSection('Damages');
      const pairs = Object.keys(dmg).sort((a,b)=>a.localeCompare(b)).map(k => [titleCase(k), dmg[k]]);

      // Table with "Target" and "Damage"
      const table = document.createElement('table');
      table.className = 'table';
      const thead = document.createElement('thead');
      const trh = document.createElement('tr');
      const th1 = document.createElement('th'); th1.textContent = 'Target';
      const th2 = document.createElement('th'); th2.textContent = 'Damage';
      trh.appendChild(th1); trh.appendChild(th2);
      thead.appendChild(trh);
      table.appendChild(thead);

      const tbody = document.createElement('tbody');
      for (const [target, dmgVal] of pairs){
        const tr = document.createElement('tr');
        const td1 = document.createElement('td'); td1.className = 'val'; td1.textContent = target;
        const td2 = document.createElement('td'); td2.className = 'val'; td2.textContent = formatScalar(dmgVal); // null -> ∞
        tr.appendChild(td1); tr.appendChild(td2);
        tbody.appendChild(tr);
      }
      table.appendChild(tbody);
      sec.body.appendChild(table);
      sections.appendChild(sec.box);
    }

    // Stats (excluding damages handled above)
    const statPairs = [];
    for (const k of statsKeys){
      if (k === 'damages') continue;
      if (has(k)){
        statPairs.push([k, itemData[k]]);
        shown.add(k);
      }
    }
    if (statPairs.length){
      const sec = makeSection('Stats');
      sec.body.appendChild(tableFromPairs(statPairs, ['Field','Value']));
      sections.appendChild(sec.box);
    }

    // Crafting / Recipe
    const craftPairs = [];
    for (const k of craftKeys){
      if (has(k)){
        craftPairs.push([k, itemData[k]]);
        shown.add(k);
      }
    }
    if (craftPairs.length){
      const sec = makeSection('Crafting');
      sec.body.appendChild(tableFromPairs(craftPairs, ['Field','Value']));
      sections.appendChild(sec.box);
    }

    // Flags / Rules
    const flagPairs = [];
    for (const k of flagsKeys){
      if (has(k)){
        flagPairs.push([k, itemData[k]]);
        shown.add(k);
      }
    }
    if (flagPairs.length){
      const sec = makeSection('Flags');
      sec.body.appendChild(tableFromPairs(flagPairs, ['Field','Value']));
      sections.appendChild(sec.box);
    }

    // Everything else (nice table, no card spam)
    const remaining = Object.keys(itemData)
      .filter(k => k !== 'damages' && !shown.has(k))
      .sort((a,b)=>a.localeCompare(b));

    if (remaining.length){
      const sec = makeSection('Other');
      const pairs = remaining.map(k => [k, itemData[k]]);
      sec.body.appendChild(tableFromPairs(pairs, ['Field','Value']));
      sections.appendChild(sec.box);
    }

    body.appendChild(sections);
    card.appendChild(header);
    card.appendChild(body);
    content.appendChild(card);
  }

  function buildUI(){
    sidebar.innerHTML = '';
    groupMeta.clear();
    itemMeta.length = 0;

    const groupOrder = Object.keys(groups).sort((a,b)=>a.localeCompare(b));
    for (const groupName of groupOrder){
      const groupEl = document.createElement('div');
      groupEl.className = 'group';

      const title = document.createElement('div');
      title.className = 'group-title';
      const left = document.createElement('div');
      left.textContent = titleCase(groupName);
      const chev = document.createElement('div');
      chev.className = 'chev';
      chev.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none"><path d="M9 6l6 6-6 6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" opacity=".9"/></svg>';
      title.appendChild(left);
      title.appendChild(chev);

      const groupContent = document.createElement('div');
      groupContent.className = 'group-content';

      title.onclick = () => groupEl.classList.toggle('open');

      const subMap = new Map();

      const subOrder = Object.keys(groups[groupName]).sort((a,b)=>a.localeCompare(b));
      for (const subName of subOrder){
        const subgroupEl = document.createElement('div');
        subgroupEl.className = 'subgroup';

        const subTitle = document.createElement('div');
        subTitle.className = 'subgroup-title';
        const subLeft = document.createElement('div');
        subLeft.textContent = (subName === 'misc') ? 'Misc' : titleCase(subName);
        const subChev = document.createElement('div');
        subChev.className = 'chev';
        subChev.style.width = '26px';
        subChev.style.height = '26px';
        subChev.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none"><path d="M9 6l6 6-6 6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" opacity=".85"/></svg>';
        subTitle.appendChild(subLeft);
        subTitle.appendChild(subChev);

        const itemList = document.createElement('div');
        itemList.className = 'item-list';

        subTitle.onclick = (e) => {
          e.stopPropagation();
          subgroupEl.classList.toggle('open');
        };

        const items = groups[groupName][subName];
        const itemNames = Object.keys(items).sort((a,b)=>a.localeCompare(b));

        for (const itemName of itemNames){
          const itemData = items[itemName];
          const item = document.createElement('div');
          item.className = 'item';
          item.textContent = itemName;

          item.onclick = () => {
            document.querySelectorAll('.item').forEach(x=>x.classList.remove('active'));
            item.classList.add('active');
            renderCard(itemName, itemData, { group: groupName, sub: subName });
          };

          itemList.appendChild(item);

          itemMeta.push({
            itemEl: item,
            subgroupEl,
            groupEl,
            groupName,
            subName,
            itemNameLower: itemName.toLowerCase(),
            itemData
          });
        }

        subgroupEl.appendChild(subTitle);
        subgroupEl.appendChild(itemList);
        groupContent.appendChild(subgroupEl);
        subMap.set(subName, { subgroupEl, itemList });
      }

      groupEl.appendChild(title);
      groupEl.appendChild(groupContent);
      sidebar.appendChild(groupEl);
      groupMeta.set(groupName, { groupEl, subMap });
    }
  }

  function applySearch(q){
    q = (q || '').trim().toLowerCase();

    for (const gm of groupMeta.values()){
      gm.groupEl.style.display = 'block';
      for (const sm of gm.subMap.values()){
        sm.subgroupEl.style.display = 'block';
      }
    }

    if (!q){
      for (const it of itemMeta) it.itemEl.style.display = 'block';

      for (const gm of groupMeta.values()) gm.groupEl.classList.remove('open');
      for (const it of itemMeta) it.subgroupEl.classList.remove('open');

      const firstGroup = sidebar.querySelector('.group');
      if (firstGroup){
        firstGroup.classList.add('open');
        const firstSub = firstGroup.querySelector('.subgroup');
        if (firstSub) firstSub.classList.add('open');
      }
      return;
    }

    const subHas = new Map();
    let firstMatchEl = null;

    for (const it of itemMeta){
      const hay = `${it.itemNameLower} ${it.groupName} ${it.subName}`;
      const match = hay.includes(q);
      it.itemEl.style.display = match ? 'block' : 'none';
      if (match){
        subHas.set(`${it.groupName}::${it.subName}`, true);
        if (!firstMatchEl) firstMatchEl = it.itemEl;
      }
    }

    for (const [groupName, gm] of groupMeta.entries()){
      let anyInGroup = false;
      for (const [subName, sm] of gm.subMap.entries()){
        const has = subHas.get(`${groupName}::${subName}`) === true;
        sm.subgroupEl.style.display = has ? 'block' : 'none';
        if (has){
          anyInGroup = true;
          gm.groupEl.classList.add('open');
          sm.subgroupEl.classList.add('open');
        } else {
          sm.subgroupEl.classList.remove('open');
        }
      }
      gm.groupEl.style.display = anyInGroup ? 'block' : 'none';
      if (!anyInGroup) gm.groupEl.classList.remove('open');
    }

    if (firstMatchEl){
      firstMatchEl.scrollIntoView({ block: 'center', behavior: 'smooth' });
    }
  }

  buildUI();

  const firstGroup = document.querySelector('#sidebar .group');
  if (firstGroup){
    firstGroup.classList.add('open');
    const firstSub = firstGroup.querySelector('.subgroup');
    if (firstSub) firstSub.classList.add('open');
  }

  search.addEventListener('input', (e)=>applySearch(e.target.value));
}

load();
</script>
</body>
</html>
